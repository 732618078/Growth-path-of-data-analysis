CREATE TABLE zs_account(
	name VARCHAR(30),
	money DECIMAL);
CREATE TABLE ls_account(
	name VARCHAR(30),
	money DECIMAL);
...
#zs:
mysql -u root -p
password
use my_test;

-- UPDATE zs_account SET money=money-2000;
START TRANSACTION; #开启事务
-------------------------------------------------------------------
#zs:

UPDATE zs_account SET money=money-2000;
 
 #ROLLBACK;  #回滚
--------------------------------------------------------------------
#ls:
UPDATE ls_account SET money=money+2000;

#ROLLBACK;  #回滚
--------------------------------------------------------------------
COMMIT;  #提交事务


-- 事务的并发问题

#脏读:

#老板要给程序员发工资，程序员的工资是3.6万/月。但是发工资时老板不小心按错了数字，
#按成3.9万/月，该钱已经打到程序员的户口，但是事务还没有提交，就在这时，程序员
#去查看自己这个月的工资，发现比往常多了3千元，以为涨工资了非常高兴。但是老板及
#时发现了不对，马上回滚差点就提交了的事务，将数字改成3.6万再提交

#实际程序员这个月的工资还是3.6万，但是程序员看到的是3.9万。他看到的是老板还没
#提交事务时的数据。这就是脏读。

#解决办法:Read committed！读提交，能解决脏读问题


#不可重复读

#程序员拿着工资卡（卡里当然是只有3.6万），当他买单时（程序员事务开启）,收费
#系统事先检测到他的卡里有3.6万，就在这个时候！！程序员的妻子要把钱全部转出充
#当家用，并提交。当收费系统准备扣款时，再检测卡里的金额，发现已经没钱了。程序
#员就会很郁闷，明明卡里是有钱的…

#一个事务范围内两个相同的查询却返回了不同数据，这就是不可重复读

#解决办法:Repeatable read


#重复读

#程序员拿着工资卡（卡里还是有3.6万），当他买时（事务开启，不允许其他事务的
#UPDATE修改操作），收费系统事先检测到他的卡里有3.6万。这个时候他的妻子不能
#转出金额了。接下来收费系统就可以扣款了。


#幻读

#程序员某一天去消费，花了2千元，然后他的妻子去查看他今天的消费记录（，妻子
#事务开启），看到确实是花了2千元，就在这个时候，程序员花了1万买了一部电脑，
#即新增INSERT了一条消费记录，并提交。当妻子打印程序员的消费记录清单时（妻子
#事务提交），发现花了1.2万元，似乎出现了幻觉，这就是幻读。

#解决办法:Serializable, 事务隔离级别效率低下，比较耗数据库性能，一般不使用


-- 事务隔离级别
#Read uncommitted,就是一个事务可以读取另一个未提交事务的数据
#Read committed,一个事务要等另一个事务提交后才能读取数据
#Repeatable read,就是在开始读取数据（事务开启）时，不再允许修改操作
#Serializable,在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读


-- 查看隔离级别
SELECT @@global.tx_isolation,@@tx_isolation;

-- 设置隔离级别

#全局
SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;
#当前会话
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;